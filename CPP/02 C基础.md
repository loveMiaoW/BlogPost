# C基础

## C语言概述

### C特点

#### 优点

- 代码量小
- 执行速度快
- 功能强大
- 编程自由

#### 缺点

- 周期长
- 移植性差
- 平台依赖库多
- 过于自由

### C理由

万物皆可C，学会C/C++走遍全球都不怕。

### C应用领域

网站后台-> 底层系统，各行各业。

### C关键字

32个关键字，9个控制语句，34种运算符，完成无数功能。

```c
//关键字 系统定义 不能重定义
auot break case char const
continue default do double else
enum extern float for goto 
if int long register return
short signed sizeof static struct
switch typedef unsigned union void 
volatile while 
```

```c
//控制语句
if else 
for
while
do while
continue
break
switch
goto
return
```

```c
//运算符
算术 
关系 + - * / % ++ --
逻辑 > <= == > !=
位 << >> ~ | &
赋值 =
条件 ?
逗号 ,
指针 * &
求字节 sizeof
强制运算 (类型)
分量运算 . ->
下标运算 []
其他 ()
```

### Hello World

```c
#include <stdio.h>

int main(int argc, char** argv) {
	printf("hello world\n");
    system("pause");
	return 0;
}
```

### System函数

```c
//执行系统命令
//mspaint notepad calc clc dir
system("cmd")
system("pause")
```

### Gcc编译

```c
//预处理->编译->汇编->链接
//gcc hello.c -o hello.exe 
hello.c -> hello.i -> hello.s -> hello.o -> hello.exe / hello(linux)
      预处理		编译		汇编			链接
    	-E		   -S		-c			  -o
```

#### 预处理

`gcc -E <源文件.c> -o <目标文件.i>`

##### 头文件展开

```c
//gcc -E <*.c> -o <*.i>
//生成预处理文件 一个简单的hello.c 会变成 800多行的.i文件，所作工作就是头文件展开
//不检查语法错误，也就意味着可以展开任意文件

```

##### 宏定义替换

```c
//宏名替换宏值
//源码
#include <stdio.h>
#define PI 3.1415 //宏定义 常量 PI

int main(int argc, char** argv) {
	printf("hello world\n");
	printf("%d\n",PI);
    system("calc");
	return 0;
}
//gcc -E 01hello.c -o 01hello.i
# 5 ".\\01hello.c"
int main(int argc, char** argv) {
 printf("hello world\n");
 printf("%d\n",3.1415);
    system("calc");
 return 0;
}
```

##### 替换注释

```c
//替换注释
#include <stdio.h>
#define PI 3.1415 //宏定义 常量 PI
int main(int argc, char** argv) {
	printf("hello world\n");
/*
	***
	***
	***
*/
	printf("%d\n",PI);
    system("calc");
	return 0;
}
//编译后
# 5 ".\\01hello.c"
int main(int argc, char** argv) {
 printf("hello world\n");





 printf("%d\n",3.1415);
    system("calc");
 return 0;
}
```

##### 展开条件编译

程序中定义了`PI` ，所以`printf`这句就不会起作用。

```c
#include <stdio.h>
#define PI 3.1415 //宏定义 常量 PI

int main(int argc, char** argv) {
	
#ifndef PI
	printf("hello world\n");
#endif
	printf("%d\n",PI);
    system("calc");
	return 0;
}

//定义PI 编译后
# 5 ".\\01hello.c"
int main(int argc, char** argv) {




 printf("%d\n",3.1415);
    system("calc");
 return 0;
}

//注释定义的PI，编译后
# 5 ".\\01hello.c"
int main(int argc, char** argv) {


 printf("hello world\n");

 printf("%d\n",PI);
    system("calc");
 return 0;
}
```

#### 编译

`gcc -S <源文件.i> -o <目标文件.s>`

##### 翻译C程序

翻译成汇编指令

```c
//
#include <stdio.h>
#define PI 3.1415 //宏定义 常量 PI
int main(int argc, char** argv) {
#ifndef PI
	printf("hello world\n");
#endif
	printf("%d\n",PI);
    system("calc");
	return 0;
}
//编译之后.s文件
	.file	"01hello.c"
	.text
	.def	__main;	.scl	2;	.type	32;	.endef
	.section .rdata,"dr"
.LC1:
	.ascii "%d\12\0"
.LC2:
	.ascii "calc\0"
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$32, %rsp
	.seh_stackalloc	32
	.seh_endprologue
	movl	%ecx, 16(%rbp)
	movq	%rdx, 24(%rbp)
	call	__main
	movq	.LC0(%rip), %rax
	movq	%rax, %rdx
	movq	%rdx, %xmm1
	movq	%rax, %rdx
	leaq	.LC1(%rip), %rcx
	call	printf
	leaq	.LC2(%rip), %rcx
	call	system
	movl	$0, %eax
	addq	$32, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.section .rdata,"dr"
	.align 8
.LC0:
	.long	-1065151889
	.long	1074340298
	.ident	"GCC: (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 7.3.0"
	.def	printf;	.scl	2;	.type	32;	.endef
	.def	system;	.scl	2;	.type	32;	.endef
```



##### 逐行检查语法错误 

编译四步骤，最耗时的一步。

```c
//报错提示
```

#### 汇编

`gcc -c <*.s> -o <*.o>`

翻译：将汇编指令翻译成对应的二级制编码。

生成目标文件，二进制文件十六进制表示。

```c
00000000
00000010
00000020
```

#### 链接

`gcc <*.o> -o <*.exe/*.out>`

生成*.exe(win)/a.exe/a.out(linux) 可执行文件。

数据段合并

数据地址回填

库引入

### 程序依赖dll库

### CPU内部结构与寄存器

#### 32位64位系统

***

#### 寄存器

8位 16位 323位

#### 寄存器 缓存 内存三者关系

三级存储体系

## 数据类型

### 常量

不会变化的数据，赋值后不能改变的量。比如"hello"->字符串常量，’A‘ -> 字符常量，10->整型数字常量，3，1415926->浮点数常量。

#### 定义方式

定义宏：#define 宏名 宏值 -> `#define PI 3.1415`。使用时候要特别注意，不需要分号。

`const` 修饰的变量为只读变量 -> `const int a = 10`

### 变量

可以改变数据的量。变量在使用前，必须有`定义`。

变量定义会开辟内存空间，变量声明不会开辟内存空间。

当编译器编译程序时，在变量使用之前，如果没有看到变量定义，编译器会自动找寻一个变量声明提升为定义。

如果该变量声明前有extern关键字，无法提升。

#### 定义

`定义语法：类型名 变量名 = 变量值`

#### 声明

没有变量值的定义->声明。

extern声明此变量->extern int a;

### 标识符

变量和常量的统称。有自己的命名规则。

#### 命名规则

通常常量大写，变量小写。大小写严格区分。

只能使用字母 数字 下划线_ 开头来命名标识符且数字不能开头（a-z/A-Z/0-9/_）。

### 整形 -> int/short/long/long long 

### sizoef 关键字

不是函数

返回一个数据类型的字节大小。单位为字节，返回值 size_t 。

signed(省略->默认效果)

```c
int -> %d

short -> %hd

long  -> %ld

long long -> %lld
```

无符号整数 unsigned 只标识数据量 没有方向（正负）

```c
unsigned int -> %u

unsigned short -> %hu

unsigned long  -> %lu

unsigned long long -> %llu
```

### 字符类型

存储一个字符。

`%c` -> 输出单个字符。

### 实型float double

浮点型，实现浮点数计算。

flaot：单精度，4字节。

double：双精度，8字节。

```c
float -> %f 默认保留六位小数 %.4f
double -> %lf 	%.3lf 保留三位 第四位四舍五入->小数点前边数，数字宽度%08.2lf 两个小数，保持8位位宽，不足用零补齐
```


### 基本概念

- 算法
    
- 程序
    
- 进程
    
- 防止越界，内存泄漏，中英文分号
    

### 数据类型

> 类型字节数
> 
> 存储区别
> 
> 不同类型数据相互转化
> 
> 特殊性
> 
> 一般随硬件的不同而不同

##### 基本类型

- 整型
    
    - 有符号
        
        - (signed)int -> 32 -2147483648 - 2147483648
            
        - short -> 16 -32768 - 32768
            
        - long -> 32
            
    - 无符号
        
        - int ->32 0 - 4294******
            
        - (unsigned)short -> 16
            
        - long ->32
            
        
        /*  
        254 -> unsigned int -> 32bit  
        -254 -> 254 -> 1111 1110 （取反加一） 补码  
        */  
        //ascll码表  0 - 127 / 255  
        //0 - 48  
        //A - 65   
        //a - 97
        
- 实型
    
    - float -> 32
        
    - double -> 64
        
        /*  
        科学计数  
        3.14  
        0.314 * 10 ^ 1 -》 浮点类型 组成  
        0.0314 * 10 ^ 2  
        314 * 10 ^ -2  
        ​  
        0.000789 -> 0.789 * 10 ^ -3  
        ​  
        31 ----------------------- 0  
        符号 --------------------------  
        ​  
        double 比 float 多32bit 全部用在精度控制  
        */
        
- 字符型
    
    - char 8bit -128 - 127
        
    - unsigned char 8bit 0 - 255
        
    
    /*  
    转化  
    1 隐士转化  
        int i;  
        float f;  
        double d;  
        char ch;  
        //低类型会向高类型转化 靠拢  
        //ch + i --> i  
        //f - d  --> d  
        //(ch + i ) - ( f - d )  
        //  i - d  
        //  d  
    2 显示转化 - > 强制类型转化  
    3 特殊性  
        3.1布尔类型bool(stdbool.h)  
            1 - true  
            0 - false  
        3.2float类型  
            不是具体的  
            范围表示，可能会失真  
            ****1 / 3 * 3 != 1  
            ****0.9999999999 === 1.0  
            ****1.0000000001 === 1.0  
            **** |f - 0| <= 10 ^ -6  
              
            int func(float f)  
            {  
                if(f < 0)  
                {  
                    return -1;   
                }  
                else if (f == 0) // fabs(f - 0) <= 1e-6 ***  
                {  
                    return 0;  
                }  
                else  
                {  
                    return 1;  
                }  
            }  
        3.3 char是否在符号  
        3.4 不同形式的0值  
            0   -   数值    
            '0' -   符号    
            "0" -   字符串  
            '\0'-     
        3.5数据类型和输出代码要相匹配(防止矛盾)  
    */
    

##### 构造类型

##### 指针类型

##### 空类型

### 变量和常量

- 常量:在程序执行过程中值不变的量
    
- 分类:整形常量 实型常量 字符型常量 字符串常量 标识常量
    
    /*  
    整形常量  
        1,790,1314....  
    实型常量  
        3.14，1415926.。。。  
    字符常量  
        由单引号引起来的   \ddd -> 三位八进制 -> '\015' 八进制  
        '\t','\o'    \dd  -> 俩位十六进制 -> '\x7f'  
    字符串常量  
        双引号引起来的 一个或者多个字符组成的序列  
        "loveMiaoW","i am Chinese","oooo-xxxx-xxxx"//"" 空串 只有尾零占空间  
        "abc\n\021\018" -> "a b c \n \021 \0 1 8"   
    表示常量  
        #define -> 见下 预处理的时候替换 不会检查语法错误，只会替换  
        原则上要加括号 区分数据  
        可以加括号 #define MAX(a,b) a > b ? a : b  
    */
    
    预处理define
    
    #include <stdio.h>  
    #include <stdib.h>  
    //#预处理的时间就解决掉了  
    #define PI 3.1415926    //3.1415926aaa  
    #define ADD 2+3  
    #define MAX(A,B) A > B ? A : B  
    #define MAX(A,B) ((A) > (B) ? (A) : (B))  
    #define MAX(A,B) \  
            ({int a = A,b = B;((A) > (B) ? (A) : (B));})  
    int main()  
    {  
    ​  
            int a,b,c;  
            int i = 5;  
            int j = 3;  
            a * PI;  
            b * PI;  
            c / PI;  
            printf("%d\n",ADD * ADD);   // 2 + 3 * 2 + 3 = 11  
            prinf("%d\n",MAX(i,j)); //5  
            printf("%d\n",MAX(i,j*2));  //6 printf("%d\n",i > j*2 ? i : j*2);  
            printf("%d\n",MAX(i++,j++));// ((i++) > (j++) ? (i++) : (j++)) 自增两次  
            printf("%d %d\n",i,j);  //7 4 标准c无解 采用第四种写法  
            return 0;  
    }
    
    shell>>gcc -E define.c
    
    # 1 "/usr/include/bits/stdlib-float.h" 1 3 4  
    # 952 "/usr/include/stdlib.h" 2 3 4  
    # 964 "/usr/include/stdlib.h" 3 4  
    ​  
    # 3 "01define.c" 2  
    ​  
    ​  
    int main()  
    {  
    ​  
     int a,b,c;  
     a * 3.1415926;//a * 3.1415926aaa  
     b * 3.1415926;//b * 3.1415926aaa  
     c / 3.1415926;//c / 3.1415926aaa  
     printf("%d\n",2+3 * 2+3);  
     return 0;  
    }
    
- 变量:在程序中可以改变的量，保存一些特定的内容，并且可能会随时改变的量
    

定义: [存储类型] 数据类型 标识符 = 值  
                TYPE NAME = VALUE;  
//贯穿整个过程

标识符:数字 字母 下划线 组成并且不能以数字开头的一个标识序列。

当我们创建一个变量的时候，会给该变量申请一块内存空间，这块内存空间有地址 - 标识符号

数据类型:基本数据类型 + 构造数据类型

值:匹配 防止精度丢失

存储类型：auto static register extern(说明型)

- auto 默认，无指定存储类型，自动分配空间，自动释放，自动回收。
    
- register:(建议性关键字)寄存器类型，快速存储(寄存器)，少快
    
    int i = 1;  
    auto i; //栈上 ->生成地址 // 不会初始化编译器会有优化  
    register int i = 1; //会把i放在寄存器上 -> 大量反复使用i值，  
    //内存结构  
    0   4G  
        code 
    
    gcc (编译器来决定)来决定，不会轻易把某个值放到寄存器中 要求1只能局部变量 大小有限制 32为大小的数据，double不可以的 没有地址，无法打印或者使用。很少有成立的时候
    
    - static 自动初始化 0 值 或者 空值，这种值有继承性 //一定会初始化，修饰变量和函数
        
    - extern 说明性，我有一个定义，不在这里，去别的地方找。不能改变说明的变量的值和类型。
        
    
    ### 变量的声明周期和作用范围
    
    - 全局变量和局部变量
        
        局部变量屏蔽全局变量。就近原则。
        
        全局变量作用域程序全部，局部作用域在程序块内。
        
        全局变量缺陷-> 容易混乱
        
    - 局部变量和局部变量
        
    - 参考
        
    
    static 类型只用一块空间
    
    > 回头看 变量作用域 static extern
    > 
    > 见见解->补充
    

### 运算符和表达式

每个运算符需要参与运算的操作数个数

结合性

优先级

运算符特殊用途

位运算