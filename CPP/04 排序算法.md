## 十大经典排序算法

### 冒泡排序

```c++
void bufSort(Ty* arr, int len)
{
	int tmpLen = len - 1;
	for (int i = 0; i < tmpLen; ++i)
	{
		for (int j = i + 1; j < len; ++j)
		{
			if (arr[i] > arr[j])
			{
				SWAP_INT(arr[i], arr[j]);//只适用于整形数据
			}
		}		
	}
}
```



添加flag优化

```c++
void bufSort(Ty* arr, int len)
{
	int flag = 1;
	int tmpLen = len - 1;
	for (int i = 0; i < tmpLen; ++i)
	{
		if (flag == 1)
		{
			flag = 0;
			for (int j = i + 1; j < len; ++j)
			{
				if (arr[i] > arr[j])
				{
					flag = 1;
					SWAP_INT(arr[i], arr[j]);//只适用于整形数据
				}
			}
		}
		
	}
}
```

提高一半的时间，优化后效率提升O(n),一次就能排好序

可以通过添加flag优化冒泡排序，效率要高，当序列在找到所有最大值之前就将序列排好序了，直接结束掉函数。

### 选择排序

发现一个好玩的bug

++i 和i++竟然不一样

msvc编译方式区别

O(n^2)

### 插入排序

对于基本有序的数列，将数字插入前面

第一个数字视为已经排好序列

```
for(int i = 1;i < len;i++)
{
	for(int j = i;j >= 1 && arr[j] < arr[j - 1];j--)
	{
		SWAP_INT(arr[j],arr[j - 1]);
	}
}
```



### 希尔排序

优化版插入排序

#### 步骤

- 间隔分组
- 组内排序
- 重新间隔分组
- 插入排序

```C++
int i = 0;
int j = 0;
int val = 0;
int tmp = 0;
for (val = len >> 1; val > 0; val >>= 1)
{
	for (i = val; i < len; i++)
	{
		tmp = arr[i];
		for (j = i - val; j >= 0 && arr[j] > tmp; j -= val)
		{
			arr[j + val] = arr[j];
		}
		arr[j + val] = tmp;
	}
}
```



### 快速排序

从数列挑选一个元素 称为 基准数

重新排列数列，所有元素比基准值小的放在基准前，大的放在基准后

```C++
void quickSort(Ty* arr, int left,int right)
{
	if (left >= right)
	{
		return;
	}
	int i = left;
	int j = right;
	Ty point = arr[i];

	while (i < j)
	{
		while (i < j && arr[j] >= point)
		{
			--j;
		}
		arr[i] = arr[j];
		while (i < j && arr[i] <= point)
		{
			++i;
		}
		arr[j] = arr[i];
	}
	arr[i] = point;
	quickSort(arr, left, i - 1);
	quickSort(arr, i + 1, right);

}
```



### 归并排序

### 堆排序

### 计数排序

### 基数排序